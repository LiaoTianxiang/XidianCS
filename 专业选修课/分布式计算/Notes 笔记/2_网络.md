# 分布式网络通信

## 底层通信

- 复习 TCP/IP 协议

  - 物理层：线缆的属性

  - 数据链路层：两个物理的点对点通信，字节流头尾，流量控制 （交换机）

  - 网络层：路由 （路由器）

  - 传输层：端到端通信 （操作系统）流量控制 tCP/UDP

    > TCP 可以保证 流量控制和数据包顺序

  - 应用层：

- **socket**

  传输层给应用层提供的标准化编程接口 

  - 流式套接字：TCP 建立一个逻辑管道，一个字节一个字节塞，流量控制可能会导致调用时的阻塞现象
  - 数据报套接字：调用一次 Send ，就会构建一个 udp 数据包，没有流量控制不会阻塞
  - 原始套接字：直接构造成 IP 包

- **如何标识一个 socket**（逻辑管道）

  五元组

  <sIP, sPort, dIP, dPort, 协议>

  本地端口号通常临时分配，远程端口号通常使用固定端口号

  socket 建立的管道是一个双向管道

  - 服务端在进行socket 连接时会建立两个管道，一个管道只用于监听，三次握手成功，服务器端就新生成一个socket，与这个客户端进行连接，监听socket继续监听下一个socket

- socket 的通信过程

  **客户端**

  1. 创建socket

  2. 连接 socket （IP ， 端口）

  3. 客户端发送请求（write）

  4. 客户端接受相应（read） 

     > write 和 read 的顺序可以由应用层自己决定，不必要客户端先发送情况

  5. 关闭套接字

  **服务器**

  1. 创建
  2. 绑定服务器地址和端口 （bind） （IP， 端口） **监听 socket**
  3. 开始监听（listen）握手成功会加入队列
  4. 接受客户端连接（accept）  **通信 socket** （**如果没有连接，则阻塞**）（accept 的返回值为新创建的通信socket）
  5. 接收客户端情况 （read）
  6. 回送响应
  7. 关闭套接字



## 同时处理多个客户端的请求

- 基于多线程的并发服务技术

  - 改进：线程池技术

- 事件驱动技术 （多路复用技术）
  - 事件驱动器（选择器）同时监视多个通道
  - 某个通道有事件到来，则将该事件交给服务线程去处理
    - 可以避免线程等待 IO 所引发的阻塞调度
  - 多路复用中的线程数是固定的，而且尽量减少线程之间的切换
  - 与 socket 相关的常用事件：可读、可写、错误、连接关闭
  - 只适合处理大量短事务的应用场景 
  - 计算密集型使用线程池技术，IO 密集型使用事件驱动技术



## 远程过程调用

使用应用程序可以向调用本地节点上的过程那样去调用一个远程节点上的子程序

- 被调用者而言也无法区分调用者来自于本地还是远程
- RPC 将面向过程的通用变成模型拓展到了分布式环境
- 实现了跨进程，跨语言，跨网络，跨平台的过程调用
- 强化了面向接口编程的编程风格
- 必须要有 RPC 中间件的支持

**RPC 一般采用同步调用方式：**

客户端发起 RPC 调用后，服务端执行，在远程调用过程期间，客户端一直处于阻塞



## 远程方法调用 RMI

将面向对象的编程模型拓展到了分布式环境

可以像调用本机上对象的方法一样调用远程主机中对象的方法

- RMI 的输入参数可能是另外一个远程对象，（存在于第三个节点）
- 在整个分布式系统范围内支持 垃圾回收



## RPC RMI 实现

调用者进程中置入 stub 模块

服务端进程中置入 skeleton 模块 （有 main 函数）

- proxy 进行参数的序列化（对象-> 二进制流）
- skeleton 反序列化，并序列化执行结果，发送给 proxy

**作用**

- 定义并利用 Socket 服务接口实现了一套调用者和被调用者之间的通信协议 （远程过程调用协议）（JAVA：JRMP）

- 实现过程参数和运算结果的序列化和反序列化

- 通信过程中的错误处理

- 远程服务进程的集中注册与发现

  > 维护一个注册中心服务器，远程对象创建时进行注册

- 远程对象的生命周期管理

- 服务端支持并发访问 （多线程）

把虚拟地址转换为物理地址的转换过程：

**CPU 硬件自动负责转化**，操作系统负责建立从虚拟地址到物理地址的转化表 （段页表），每个进程有自己独立的页表，所以不能实现跨进程直接共享内存。

> 操作系统中的共享内存通信地址，是要向操作系统申请同一块 物理内存，并将这块物理内存分别映射到两个进程的虚拟空间中。

## Java RMI 中间件

- JDK 提供的一套 RMI 中间件
- RMIRegistry: 注册中心程序 + 分发器
- rmic ：植入 stub 和 skeleton

RMI 不支持直接访问远程对象的属性

1. 必须知道对方的引用地址（强耦合）（使用注册中心来缓解）
2. 调用是同步调用

## 面向消息中间件 MOM

Message Oriented Middleware

提供一种分布式消息队列服务，节点 之间可以实现基于消息的形式灵活得异步通信

> 发送方可以在任意时刻发送消息，不必等待接收方上线，不必等待消息发送成功
>
> 接收方不必以阻塞方式等待消息的到来，（中间件主动通知进程接受消息，回调函数）

- 点对点通信模式：
  - 用于生产者和消费者之间的点对点通信
  - 每个消息只有一个消费者，不可重复消费
  - 高级队列模式：带优先级的队列，支持持久性的队列（消息存储进硬盘）
- 发布，订阅通信模式：
  - 以主题为中心，支持像一个特定的消息主题发布消息，多个订阅者可以同时关注并接收来自特定消息主题的消息
  - 实现：广播、组播和多对多通信模式

**常见的 MOM 中间件**

- ActiveMQ
- 内部支持多种通信协议
- 必须部署中心服务器作为消息路由代理



**JMS java message service**

为 java 应用程序提供的访问不同 mom 中间件的同一 API 接口

类似于 JDBC 或 ODBC

