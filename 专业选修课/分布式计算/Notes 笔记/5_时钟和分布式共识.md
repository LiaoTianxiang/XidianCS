交报告：

1. 实验内容
2. 设计思想
3. 遇到的问题及解决办法
4. 实验结果
5. 心得体会



# 时钟和分布式共识

## 抽象理论模型

- 交互模式

  - 节点间的好友模式

    - 全连接网络：任意节点可以向任意节点发送消息
    - 受限连接网络：每个节点只能向协议规定的部分节点发送消息

  - 同步交互模式

    - 节点的交互按照周期进行，每个周期包含一次消息发送和消息接受过程
    - 对节点物理时钟的同步，消息传输最大延时，消息最大处理时间做了假设

  - 异步交互模式

    可以在任意时刻发送和接受消息

- 信道故障

  - 丢失、乱序、传输延迟

- 节点故障

  - 失效停止模式

    节点一旦发生故障就 停止工作，故障期间不发送任何消息

  - 拜占庭模式

    节点发生故障可能做出任意动作，例如发送非协议规定的错误消息，甚至故意扰乱分布式系统的消息

  

## 逻辑时钟

> 由于物理时钟很难做到精确的同步，所以在分布式系统中无法用物理时钟对事件的发生进行排序。
>
> 分布式系统中很多问题的关键在于不同的节点对多个事件的发生顺序达成一致就可以，并且达成的顺序不能破坏因果关系。
>
> Lamport提出的逻辑时钟概念就是为了解决分布式系统中事件的时序问题，并且能够保证如果事件a导致事件b（记为：a➔b，表示a是b的潜在原因），则一定有C(a)<C(b)。（C(a)为事件a发生的逻辑时间戳， C(b)为事件b发生的逻辑时间戳）

- 逻辑时钟的产生算法

  每个节点维护一个不断增加的整数作为本地逻辑时钟
  节点内事件的发生（消息产生、消息发送、消息接收都是事件）会触发逻辑时钟的增长
  节点 i 发出的每个消息都绑定一个二元组：
       <本地逻辑时钟Ci，节点ID号i>
  每发生一个新事件就让本地逻辑时钟Ci加1
  假定节点j接收到一个消息m，其时间戳为<Ci, i>, 则节点j将自己的逻辑时间调整为：
        Cj =1 + max{ Cj,  Ci }

- 逻辑时钟的性质

  a 导致 b 则一定有 C(a) < C(b)

- **两段锁协议** 2PL

  > 前提：假定有N个数据库镜像服务器，多个客户端都有数据更新需求。每个服务器都持有一个唯一的锁。
  > 客户端：
  > 向每个服务器都发出获取锁的请求；  
  > IF 能够成功获得**半数以上服务器的锁**， THEN： 
  >                向所有服务器发送自己的Update请求；**同一时间只有一个客户端能拿到半数以上的锁**
  >                在所有服务器反馈成功后，释放自己拥有8的所有的锁。
  >        ELSE:
  >                **释放自己拥有的所有的锁** 避免死锁
  >                随机等待一段时间之后，goto (1)
  > 服务器端：
  > 接收到锁请求消息，如果自己的锁没有发放，则其发放给该客户端；否则返回失败消息。
  > 接收到锁释放消息，则将自己的锁记为未发放状态。
  > 接收到Update消息，则根据消息参数更新自己的数据库状态。

- 使用逻辑时钟，解决数据库一致性问题

  > 基本思想：
  >
  > （1）服务器都维护各自的逻辑时钟，事件发生、接收消息都会触发逻辑时钟的增长；服务器发送的每个消息都绑定逻辑时间戳；
  >
  > （2）客户端将自己的Update消息发送给任意一个服务器；
  >
  > （3）服务器收到任意的Update消息，都将其广播给其他服务器；
  >
  > （4）每个服务器都维护一个Update消息队列，队列中的消息按逻辑时间戳排序。
  >
  > （5）每个服务器都依次取出Update消息队列中头部的消息进行处理，即根据消息参数对数据库状态进行更新。
  >
  > 关键点：如果每个消息都被广播给了所有服务器，那么所有服务器的Update消息队列中的消息排序都是一致的；按照该顺序更新自己的数据库状态，也能够使数据库保持一致。
  >
  > 前提：服务器之间消息不会丢失、不会乱序、服务器不会失效。

  统一排序消息多播协议：

  服务器执行如下协议：

  （1）当收到了一个来自于客户端的Update消息，则将其广播给其他所有服务器（包括自己）；

  （2）当收到了一个来自于服务器的Update消息，

  ​       （a）将该消息按时间戳先后顺序放入自己的队列中；

  ​       （b）观察队列**头部**的消息，如果关于该消息尚未广播过 ACK消息，则向所  有服务器广播关于该消息的ACK消息

  （3）当收到一个ACK消息，

  ​        （a）将队列中对应的Update消息的ACK计数加1

  ​        （b）观察队列头部的Update消息，如果关于该消息已经收到了所有服务  器的ACK消息，则将其从队列中取出，并  执行该Update动作（对数据  库进行更新）

  

  定理：如果自己队列中处于头部的Update消息收到了所有服务器的ACK消息，则该Update消息消息也位于所有节点内部队列的头部。（用反证法证明）
  
- **CAP 定理**

  - 一致性：Consistensy 所有镜像的数据保持一致
  - Partition Tolerance 割断容忍性：允许部分节点和其他节点断裂 （线路断、节点失效）
  - Availability 可用性：发出的请求在规定时间段内总能返回结果（请求响应延时短，可用性高）

  CAP 定理：在设计分布式系统时，三者只能取其二，不能三者兼得



## 分布式共识协议

节点故障容忍的分布式共识协议

- 终止性：有限时间内达成一致的决策
- 共识性：不同节点的最终决策结果相同
- 合法性：决策的结果必须等于某个进程的提案

**同步模型下的分布式共识协议**

协议假设：

- 节点构成：n 个节点构成，最多有 F 个节点故障
- 同步通信模型假设：消息传输延迟有上限，消息不会丢失，每个周期都包含消息的接受和发送过程
- 推论：一个周期内，正常节点的所有消息都会被所有正常节点收

- 故障模式：失效停止

**异步模型下的分布式共识协议**

- 在异步模型下，只要有一个节点失效，就无法达成共识（满足三个特性）
- 实际应用时，不完全保证终止性
  - Paxos 协议：可以容忍不超过 n/2 的节点产生FileStop故障 （私有链）
  - Raft 协议
  - PBFT 协议：可以容忍 不超过 n/3  的节点产生拜占庭故障 PBFT 需要用 7 个节点，容忍 2 个节点故障
  - 比特币 (共有链)



**考试**

- 看ppt
- 试卷有八九道问答题，没有填空选择
- 

