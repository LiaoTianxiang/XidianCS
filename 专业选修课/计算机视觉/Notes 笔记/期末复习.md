## 图像和图像滤波

- 什么是滤波

  > 形成一个新的图像，其像素是原始像素的组合

- 什么时候利用滤波

  - ==**增强图像：**== 降噪、锐化
  - **==提取信息：==** 提取边缘或轮廓


**滤波的种类：**

- 线性滤波：用相邻的线性组合 （加权和）替换每个像素

  - 线性组合的系数称为权重核

  **卷积：**(权重核反转（水平和垂直）)
  $$
  G [ i , j ] = \sum _ { u = - k } ^ { k } \sum _ { v = - k } ^ { k } H [ u , v ] F [ i - u , j - v ]
  $$
  记为
  $$
  G=H*F
  $$
  **相关：**
  $$
  G [ i , j ] = \sum _ { u = - k } ^ { k } \sum _ { v = - k } ^ { k } H [ u , v ] F [ i + u , j + v ]
  $$
  记为：
  $$
  G = H \otimes F
  $$

- 高斯滤波

  > ==从图像中删除 「高频」分量 （低通滤波器）==

  ==高斯核函数==：
  $$
  G _ { \sigma } = \frac { 1 } { 2 \pi \sigma ^ { 2 } } e ^ { - \frac { \left( x ^ { 2 } + y ^ { 2 } \right) } { 2 \sigma ^ { 2 } } }
  $$




**滤波的应用**

- 锐化滤波器：
  $$
  F + \alpha (F-F*H)
  $$

- 阈值滤波器
  $$
  g ( m , n ) = \left\{ \begin{array} { c c } { 255 , } & { f ( m , n ) > A } \\ { 0 } & { \text { otherwise } } \end{array} \right.
  $$
  ==阈值滤波器不是线性滤波==

- 相关和卷积的定义和关系

- 高斯核

  - 调节哪个参数

- 什么是线性滤波器

- 去燥使用什么滤波



## 边缘检测

### 边缘的特征

> 怎样通过导数来反映边缘

- ==对于图像强度的一阶导数，边缘对应于导数的极值==

**如何计算数字图像的导数？**

1. 重建连续图像，然后计算导数

2. 采用离散导数（有限差分）: ==图像的梯度相当于两个相邻像素之间的差值==
   $$
   \frac { \partial f } { \partial x } [ x , y ] \approx F [ x + 1 , y ] - F [ x , y ]
   $$
   可以使用线性滤波器实现

   ==梯度的方向 **垂直于边缘的方向**==，梯度的方向是 图像函数 f(x,y) 变化最快的方向，当图像中存在边缘时，一定有较大的梯度



### 图像梯度

图像梯度是图像函数在 x ,y 两个方向的导数，

幅值:
$$
\| \nabla f \| = \sqrt { \left( \frac { \partial f } { \partial x } \right) ^ { 2 } + \left( \frac { \partial f } { \partial y } \right) ^ { 2 } }
$$
方向：
$$
\theta = \tan ^ { - 1 } \left( \frac { \partial f } { \partial y } / \frac { \partial f } { \partial x } \right)
$$
**==要计算图像梯度，首先要图像去噪，使用高斯核在图像上卷积，平滑图像==**

可以将两次滤波 （高斯滤波、差分滤波）合成一步实现

![mark](http://media.sumblog.cn/blog/20190102/XhVYP5it42Yb.png?imageslim)

#### 二维边缘检测使用的图像算子：

1. Sobel 算子

   ![mark](http://media.sumblog.cn/blog/20190102/PIUiMGyShLVT.png?imageslim)

### 非最大抑制

检查像素是否为**沿梯度方向的局部最大值** （需要进行像素差值？）

2. ==Canny 边缘检测器==

   1. 用高斯导数滤波
   2. 获得梯度的幅值和方向
   3. 非最大抑制
   4. 连接与滞后阈值化：
      - 定义高低两个阈值
      - 用==高阈值来寻找边缘曲线的起点，用低阈值来确定后继点==，进行连接

   **Canny 边缘检测器的参数：**

   - $\sigma:$ 高斯模糊的宽度：大的 $\sigma$ 可以检测大尺度边缘，==$\sigma $ 越小，能检测到的细微边缘就越多==
   - 高阈值
   - 低阈值

- 图像的导数
- 图像的梯度是什么 （两个方向的导数）（复制和方向）
- 去噪
- 二维边缘检测
  - 列举几个图像算子
- 费最大值抑制
- 边缘检测器



## 图像的插值和重采样

### 图像采样

- 采样率

  ==**奈奎斯特采样率：** 采样率 >= 2*图像中的最大频率==

**若原始图像的频率过高，先对图像滤波，然后子采样**，构建高斯金字塔

### 图像插值

- 最近邻差值：重复 n 次
- **双线性插值**： 利用输入图像中与输出图像像素点映射位置最邻近的4个像素点的颜色值(或灰度值)计算输出图像中像素点的颜色值(或灰度值)
- 双三次插值：为了得到更精确的(x',y')的颜色值(或灰度值)g(x',y'),就不仅需要考虑与(x',y')点最邻近的四个点对它的影响,还要考虑到该点周围16个相邻点的颜色值(或灰度值)对它的影响。





## 角点检测

Harris 角点检测：将窗口平移，比较平移前后 w 内每个像素的差异平方和（SSD）
$$
E ( u , v ) = \sum _ { ( x , y ) \in W } [ I ( x + u , y + v ) - I ( x , y ) ] ^ { 2 }
$$

$$
\begin{aligned} E ( u , v ) = & \sum _ { ( x , y ) \in W } [ I ( x + u , y + v ) - I ( x , y ) ] ^ { 2 } \\ \approx & \sum _ { ( x , y ) \in W } \left[ I ( x , y ) + I _ { x } u + I _ { y } v - I ( x , y ) \right] ^ { 2 } \\ \approx & \sum _ { ( x , y ) \in W } \left[ I _ { x } u + I _ { y } v \right] ^ { 2 }\\  \approx Au^2+2Buv +Cv^2\\ \end{aligned}
$$

$$
A = \sum _ { ( x , y ) \in W } I _ { x } ^ { 2 } \quad B = \sum _ { ( x , y ) \in W } I _ { x } I _ { y } \quad C = \sum _ { ( x , y ) \in W } I _ { y } ^ { 2 }
$$

**算法实现：**

1. 计算图像在 X， Y 两个方向的梯度

2. 计算两个方向上梯度的乘积

3. 使用高斯函数对 $I_x^2,I_y^2,I_xI_y$ 进行高斯加权，生成矩阵的元素 A，B，C

4. 计算每个像素的 Harris 响应值 R， 并对小于某个阈值的 R 置 0
   $$
   R = \left\{ R : \operatorname { det } M - \alpha ( \operatorname { trace } M ) ^ { 2 } < t \right\}
   $$

5. 在邻域内进行非最大抑制，局部最大值即为图像的角点





## 特征不变性

我们希望角点的位置对光度变换具有不变性 （图像变换之后，角点位置不变），对几何变换具有协变性 （相应位置检测到同一特征）

**不变性：**

- 对平移、旋转协变
- 对强度平移具有不变性，对强度缩放不具有不变性
- 对缩放不具有不变性
  - 需要同时在位置和尺度上查找：自动尺度选择

**自动尺度选择：**

- 在高斯金字塔中使用固定大小的窗口，寻找具有局部最大值的尺度

**斑点检测：**

> 斑点是指二维图像中和周围颜色有颜色差异和灰度差异的区域,因为斑点代表的是一个区域,所以其相对于单纯的角点,具有更好的稳定性和更好的抗干扰能力.

- 核函数：

  - 高斯拉普拉斯：
    $$
    \nabla ^ { 2 } g = \frac { \partial ^ { 2 } g } { \partial x ^ { 2 } } + \frac { \partial ^ { 2 } g } { \partial y ^ { 2 } }
    $$

  - 高斯差分函数
    $$
    D o G = G ( x , y , k \sigma ) - G ( x , y , \sigma )
    $$

- 当 $$\sigma = r/\sqrt{2}$$ 时，响应最大，图像黑白反向时，响应最小，因此将高斯拉普拉斯算子响应达到峰值的 $\sigma$ 值，称为特征尺度



- 怎么实现特征的不变
- Harris 检测的步骤



## 特征描述与匹配

### 特征描述符

- **MOPS**:

  1. 选取特征点周围 40*40 的方形窗口
  2. 缩放到 1/5 大小
  3. 旋转特征向量方向到水平
  4. 在以特征为中心的 8*8 方形窗口内采样
  5. 规格化 （强度减去平均值，除以标准差，均值为0，方差为1）

- **SIFT：**尺度不变特征转换

  ![mark](http://media.sumblog.cn/blog/20190102/52PLX111WYbj.png?imageslim)

  1. 在所检测的特征周围取 16*16 的窗口
  2. 为每个像素计算边缘方向
  3. 去除弱的边缘方向（设定阈值）
  4. 为剩余边缘方向建立直方图

### 特征匹配

- 特征距离

  - 更好的方法：距离比

    $f_2$ 是 $f_1$ 在 $I_2$ 中最好的 SSD 匹配，$f_2^\prime$ 次之
    $$
    距离比 = \frac{||f_1-f_2||}{||f_1-f_2^\prime||}
    $$

- 测量特征匹配的性能

  - 真正例率（TPR） （召回率） = 匹配到的真正例数 / 所有真正例数
  - 假正例率 （FPR） = 匹配到的假正例数/所有真正例数
  - ROC 曲线：以 FPR 为横轴，TPR 为纵轴
  - AUC：曲线下的面积，越大越好



## 变换与卷绕

什么是图像卷绕：**更改图像的定义域**

**常见的变换**

- 平移
- 欧式变换：平移+旋转
- 相似变换：平移+旋转+等比放缩
- 仿射变换：平移+旋转+等比放缩+剪切
- 投影变换：原来平行的线不再平行，但还是保持直线性

### 线性变换

- 等比缩放： 比例S
- 旋转角度 
- 剪切
- 镜像

> **线性变换的性质**
>
> 原点到原点
>
> 直线到直线
>
> 平行线保持平行
>
> 比率被保持
>
> 线性变换的组合是线性变换

平移不是 2D 坐标上的线性变换，我们需要 **添加一个坐标** -> **齐次坐标**

## 仿射变换

**任何最后一行 为 [0,0,1] 的 3·3 矩阵表示的转换称为仿射变换**，**仿射变换是线性变换和平移的组合**

变换完成后，平面位置不变

基本的仿射变换：

- **平移、缩放、2D 平面旋转、剪切** 

  ![mark](http://media.sumblog.cn/blog/20190105/Je0CygVwaYrM.png?imageslim)

- **仿射变换是线性变换 + 平移**

**性质**

- 原点不一定到原点
- 直线到直线
- 平行还平行
- 保持比率
- 闭包

## 透视变换、投影变换、同态映射 

> 最后一元素固定为1 ，共有8个参数， **是成像平面的变换**，仿射变换是特例

- 原点不一定映射到原点
- 平行线不一定保持平行
- 不保持比率
- 闭包



### 卷绕

卷绕有两种：

1. 前向卷绕
2. 反向卷绕

变换后的像素位置如果不是整数： **将像素值分配给四个最近邻，记录每个点的权重并在最后归一化**

> 效果：混叠与模糊

- **反向卷绕**

  先获取每个像素在原图像中对应的位置处的像素值 （逆变换）

  如果像素位置不是整数，利用原来相邻像素值插值

  - 可能的插值滤波器
    - 最近邻
    - 双线性
    - 双三次
    - 窗 sinc
  - 需要防止锯齿和混叠（需要预先滤波）



- 变换有哪几种

- 卷绕有两种

  卷绕之后产生了非整数值怎么办

- 常见的变换

  - 旋转
  - 平移
  - 基本仿射变换
  - **仿射变换的含义是什么**



## 图像配准

配准算法的流程，怎么实现

- 特征提取
- 匹配
- 反向变换
- 插值

优化方式

**最小二乘法**

### 图像配准算法

**给定图像 A 和 B**

1. 计算 A、B 的图像特征
2. 匹配 A、B 之间的特征
3. 使用匹配集计算 A 到 B 的单应映射矩阵的最小二乘解

### 最小化残差平方和

定义残差：
$$
\begin{array} { l } { r _ { \mathbf { x } _ { i } } \left( \mathbf { x } _ { t } \right) = \left( \mathbf { x } _ { i } + \mathbf { x } _ { t } \right) - \mathbf { x } _ { i } ^ { \prime } } \\ { r _ { \mathbf { y } _ { i } } \left( \mathbf { y } _ { t } \right) = \left( \mathbf { y } _ { i } + \mathbf { y } _ { t } \right) - \mathbf { y } _ { i } ^ { \prime } } \end{array}
$$
将 n 个点形成的 2n 个方程写成矩阵方程：
$$
\left[ \begin{array} { l l } { 1 } & { 0 } \\ { 0 } & { 1 } \\ { 1 } & { 0 } \\ { 0 } & { 1 } \\ { 0 } & { 1 } \\ { \vdots } \\ { 1 } & { 0 } \\ { 0 } & { 1 } \end{array} \right] \left[ \begin{array} { l } { x _ { t } }  \\ { y _ { t } } \end{array} \right] = \left[ \begin{array} { c } { x _ { 1 } ^ { \prime } - x _ { 1 } } \\ { y _ { 1 } ^ { \prime } - y _ { 1 } } \\ { x _ { 1 } ^ { \prime } - x _ { 2 } } \\ { y _ { 2 } ^ { \prime } - y _ { 2 } } \\ { \vdots } \\ { x _ { n } ^ { \prime } - x _ { n } } \\ { y _ { n } ^ { \prime } - y _ { n } } \end{array} \right]
$$

$$
At =b
$$

找到 t ，最大限度的减少
$$
\| \mathbf { A } \mathbf { t } - \mathbf { b } \| ^ { 2 }
$$

$$
\begin{array} { c } { \mathbf { A } ^ { \mathrm { T } } \mathbf { A } \mathbf { t } = \mathbf { A } ^ { \mathrm { T } } \mathbf { b } } \\ { \mathbf { t } = \left( \mathbf { A } ^ { \mathrm { T } } \mathbf { A } \right) ^ { - 1 } \mathbf { A } ^ { \mathrm { T } } \mathbf { b } } \end{array}
$$

对于仿射变换：
$$
\left[ \begin{array} { l } { x ^ { \prime } } \\ { y ^ { \prime } } \\ { 1 } \end{array} \right] = \left[ \begin{array} { l l l } { a } & { b } & { c } \\ { d } & { e } & { f } \\ { 0 } & { 0 } & { 1 } \end{array} \right] \left[ \begin{array} { l } { x } \\ { y } \\ { 1 } \end{array} \right]
$$
有六个未知数，每个匹配有两个方程，我们需要三个匹配

残差：
$$
\begin{aligned} r _ { x _ { i } } ( a , b , c , d , e , f ) & = \left( a x _ { i } + b y _ { i } + c \right) - x _ { i } ^ { \prime } \\ r _ { y _ { i } } ( a , b , c , d , e , f ) & = \left( d x _ { i } + e y _ { i } + f \right) - y _ { i } ^ { \prime } \end{aligned}
$$
对于同态映射（透视变换）
$$
\left[ \begin{array} { c } { x _ { i } ^ { \prime } } \\ { y _ { i } ^ { \prime } } \\ { 1 } \end{array} \right] \cong \left[ \begin{array} { l l l } { h _ { 00 } } & { h _ { 01 } } & { h _ { 02 } } \\ { h _ { 10 } } & { h _ { 11 } } & { h _ { 12 } } \\ { h _ { 20 } } & { h _ { 21 } } & { h _ { 22 } } \end{array} \right] \left[ \begin{array} { c } { x _ { i } } \\ { y _ { i } } \\ { 1 } \end{array} \right]
$$

$$
\begin{aligned} x _ { i } ^ { \prime } \left( h _ { 20 } x _ { i } + h _ { 21 } y _ { i } + h _ { 22 } \right) & = h _ { 00 } x _ { i } + h _ { 01 } y _ { i } + h _ { 02 } \\ y _ { i } ^ { \prime } \left( h _ { 20 } x _ { i } + h _ { 21 } y _ { i } + h _ { 22 } \right) & = h _ { 10 } x _ { i } + h _ { 11 } y _ { i } + h _ { 12 } \end{aligned}
$$

![mark](http://media.sumblog.cn/blog/20190105/LyDbpPwVzvUz.png?imageslim)

Ah = 0 的非平凡最小二乘解，即为 $A^TA$ 具有最小特征值的特征向量

## RANSAC 随机抽样一致

如何计算

- 随机抽取
- 计算匹配误差

### Ransac 算法

1. 随机选择 S 个样本
   - 通常 s 等于可以求解模型的最少样本数量
2. 使用这 s 个样本求得一个解
3. 计数符合模型的 inliers 数
4. 重复 N 次
5. 选择具有最多 inliers 数的模型
6. 使用所有的 inliers 点，采用最小平方拟合

### 实验轮数的确定

- $p$ 数内点的概率
- $s$ 是每次实验使用样本点的数目
- $P$ 为实验最终成功找到正确解的概率
- $R$ 为实验轮数

$$
\begin{array} { l } {{ 1 } - { P } = \left( { 1 } -  { p } ^ { s } \right) ^ { { R } } } \\ {  { R } = \frac { \log ( 1 - \boldsymbol { P } ) } { \log \left( \mathbf { 1 } - \boldsymbol { p } ^ { s } \right) } } \end{array}
$$



## 相机

哪些是内参，哪些是外餐

坐标系

- 如何映射
- 从相机坐标系到像素坐标系

### 相机参数

照相机由几个参数描述：

- 从世界坐标系原点到光心COP的平移变换 T (外参数)
- 描述相机方向的旋转变换 R （外参数）
- 焦距 f、主点(x’c, y’c)、像素大小($s_X$,$s_Y$)（内参数） 

### 从相机坐标到像素坐标

![mark](http://media.sumblog.cn/blog/20190105/cCfNHuzmohgK.png?imageslim)

从世界坐标到像素坐标

![mark](http://media.sumblog.cn/blog/20190105/DYepTiBLDtcu.png?imageslim)
$$
\boldsymbol { \Pi } = \mathbf { K } [ \mathbf { R } | - \mathbf { R } \mathbf { c } ]
$$


## 全景图

- 实现全景图的流程

  - 围绕光心旋转相机，从同一位置拍摄一系列图像

  - 计算第二个图像与第一个图像之间的变换

    图像坐标系 -> 相机2坐标系 -> 相机 1 坐标系 （乘以旋转矩阵）-> 图像坐标系

  - 变换使得两个图像部分重合

  - 将两者融合在一起创建拼图

- 什么时候用柱面投影，什么时候用球面投影

## 单视图建模

- 什么是无穷远点（消失点）

  消失点是无穷远处一个点的投影，投影到图像中的一个有限点

  - 任何两条平行线都有相同的消失点

- 怎么用消失点

### 用消失点计算高度

![mark](http://media.sumblog.cn/blog/20190107/JckkAajTkzOX.png?imageslim)

### 相机标定

==估计相机的参数==

## 立体视觉

- 怎么求深度图
  - 三角形相似原理

### 深度计算

![mark](http://media.sumblog.cn/blog/20190107/lReum36PdnLL.png?imageslim)



## 双视图几何

- **基本矩阵：** 将图像 1 中的点，映射到图像 2 中的极线
- 极点：两个光心的连线与成像平面的交点
- 极平面：由两个相机坐标原点、和物点P组成的平面
- 级线：极平面与两个像平面的交线

极线

基础矩阵（本质矩阵）：用于已标定

基本矩阵：用于未标定



## 运动恢复结构

相机标定的步骤

**最小化重投影误差平方和**

- 为什么需要多视图：采用非线性最小二乘法进行优化

## 光的感知

- 光谱（感光细胞）

## 光度测量

### 朗伯反射率

$$
I = k_dN*L
$$

图像强度 = 反照率\*表面法线方向\*光源方向

对每一个像素可以求解此式获得表面法线方向

- 如何通过法线计算深度

### 法线计算深度

通过相邻两个像素点 xyz 做差 ，可以获得一个表面向量，这个表面向量和法线垂直，每条法线可以给出 z 的两个线性约束 $z_{x+1,y}, z_{x,y}$ ，通过求解矩阵方程计算 z 的值

![mark](http://media.sumblog.cn/blog/20190107/CMph5G5dVayT.png?imageslim)

## 图像分类

- 过程

1. 收集带标签的图像数据库
2. 使用机器学习算法训练图像分类器
3. 用测试图像评估分类器的效果

- 有哪些分类的方式
  - 最近邻：寻找最相似的训练图像
  - K近邻：从训练结果中查找 k 个最接近的点，进行投票
  - 线性分类器：定义一个评分函数，寻找超平面，将正例和反例分开

- 损失函数

  用来评判评分函数好还是不好，定义一个损失函数，在训练集上评估我们对分类分数的不满意程度

  - **为什么要正则化**：防止模型太复杂，过拟合，正则化的形式
    - 表达对权重的偏好
    - 使模型简单，泛化能力强
    - 增加曲率，有利于优化
  - 如何优化（梯度下降）
    - 梯度是沿各维的偏导数向量
    - 下降最快的方向是负梯度方向



## 深度学习

- 有哪些层
  - 全连接层
  - 卷积层
  - 池化层：缩小尺寸（对每层激活图分别做）
- 反向传播是如何传播的
  - 通过上游梯度计算本地梯度
    - 加法门：梯度分发
    - 最大门：梯度路由
    - 乘法门：梯度交换