## 扩充

### 名字空间

```c++
namespace ns{
    int inflag;
}
ns::inflag = 0;
using ns::inflag;
```

- 允许使用没有名字的名字空间，作用域为从名字空间位置开始到文件结束

**作用域运算符：**

`::a` 作用域运算符前没有名字，**表示全局作用域中的变量**

### 常量定义

- C `#define` 定义符号常量，预编译时完成字符置换，称为宏替换

- c++ 通过给常量命名的方式定义常量：

  ```c++
  const int MaxLine = 1000;
  ```

  用 `const` 定义标识符常量时，一定要初始化，常量不能用赋值运算符进行赋值

### 原型声明

如果函数调用的位置在函数定义之前，函数调用之前必须对所调用的函数做函数原型声明

### 函数重载

同名函数参数个数和类型不同，实现不同功能

*不予许重载只有返回值类型不同的函数*

### 函数模板

```c++
template <typename T>
T max(T a,T b){
    ....
}
```

**适用于函数的参数个数相同但类型不同，且函数体相同的情况**

定义函数模板时，可以使用 **多个类型参数**，每个类型参数前面需要加上关键字 `typename` 或 `class` ，用逗号分隔

```c++
template <class T1, class T2>
T1 max(T2 a, T2 b){
    
}
```

### 带有默认参数的函数

如果有多个形参，可以指定任意个默认值，**指定默认值的参数必须放在形参列表的最右边**

*重载函数与默认参数函数共同使用，会产生二义性问题*

### 引用

对一个变量起的另一个名字

```c++
int &refmax = max
```

- **引用在定义的时候就需要初始化** (指针不需要初始化)
- 引用的初始化值不能是一个常数

- **一旦引用被声明，就不能再指向其他的变量**

- 对引用的初始化，**可以使用另一个引用**

  ```c++
  int &b = a; int &c = b;
  ```

- 可以对引用做取地址操作

- **对常量的引用，需要声明常引用**

- 非法的引用：

  - `void &a`
  - `int &a[6]`
  - `int &*p`

可以把变量的引用作为函数形参，传送变量的别名

**可以把函数定义为引用类型，这时函数的返回值是一个变量，*可以对其返回值进行赋值操作* **

```c++
int  a=4;
int  &f(int  x)
{    a=a+x;
      return  a; }
int main()
{    int   t=5;
     cout<<f(t)<<endl; //a=9
    f(t)=20;			//a=20
    cout<<f(t)<<endl;	//a=25
     t=f(t);			//t = a = 30
    cout<<f(t)<<endl;   // a = 60
    return 0; 
}

```

若函数返回值为引用，则必须返回一个全局变量，或静态局部变量的引用（存储在静态区）**可以将函数放置在赋值等号的左边，给返回的变量引用赋值**

### 内联函数

编译时将所调用函数的代码嵌入到主函数

```c++
inline int max(int a, int b){
    return a>b?a:b;
}
```

### 字符串变量

string 不是基本类型，是一个字符串类

- 定义字符串变量时不需要指定长度
- 可以对字符串变量中的某一个字符进行操作 `string2[2] ='a' 
- 复制 `=` ，字符串连接 `+`，字符串比较
- 字符串数组

### 动态分配/撤销内存

`new` 从 **堆** 中分配一块与类型相适应的存储，分配成功，返回存储空间的起始地址

```c++
    <指针变量名>=new <类型>;
    <指针变量名>=new <类型>(<初值>);
    <指针变量名>=new <类型>[<元素个数>]；
```

delete 释放指针变量名指向的动态存储空间

```c++
    delete <指针变量名>  
    delete[] <指针变量名>
```

delete[] 用于释放指针指向的连续存储空间

