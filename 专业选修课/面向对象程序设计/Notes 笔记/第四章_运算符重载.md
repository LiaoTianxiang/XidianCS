# 第四章 运算符重载

- 运算符重载的定义
- 运算符重载的两种形式 
- 友元的作用和定义 
- 类型转换运算符重载



> 运算符重载就是为用户自定义类型重新定义运算符，使同一个运算符既可以作用于预定义的数据类型，也可以作用于用户自定义的数据类型。
>
> 运算符重载本质上是一种特殊的函数重载

## 运算符重载的形式

### 1. 重载为类的成员函数

```c++
<函数类型> operator <运算符>(<参数表>)
{	函数体	}
```

```
A  operator +  (A &); //重载了A类的“+”运算符
```

- 不允许重载三个操作数的运算符
- **重载为成员函数时，最多有一个形参** （可以没有参数）
- **左操作数必须为对象本身，由左操作数调用右操作数**

前置运算符的重载：

```
<type> operator ++( )
```

后置运算符的重载：

```
<type>  operator ++(int)		
```

**运算符重载函数不能定义为静态的成员函数，因为需要用到 this 指针**

### 2. 重载为类的友元函数

将运算符的重载函数定义为友元函数，参与运算的对象全部成为函数参数。

```
friend <函数值类型> operator <运算符>(<参数表>)
{
        <函数体>；
}
```

- 如果重载双目运算符，则**第一个参数代表左操作数**，第二个参数代表右操作数

++为前置运算符时，它的运算符重载函数的一般格式为：

A operator ++(A &a)

++为后置运算符时，它的运算符重载函数的一般格式为：

A operator ++(A &a,  int)

## 友元

> 可以直接访问当前类中的私有成员，又不改变其私有成员的访问权限

友元可以是**一个全局函数、另一个类的成员函数或者是一个类**。分别**称为友元函数和友元类**。友元类的所有成员函数都是友元函数，可以访问被访问类的任何成员。

- 友元声明以关键字friend开始，只能出现在被访问类的定义中。

```
friend  <函数值类型>  <函数名>(<参数表>);
friend  class <类名>; 
```

- 友元函数不受类中访问权限关键字的限制，可以把它放在类的私有、公有或保护部分，其作用都是一样的。换言之，在类中对友元函数指定访问权限是不起作用的。

```c++
class   B  ;	//先定义A类，则首先对B类作引用性说明
class   A{
   ......		//类A的成员定义
   public:
   void  fun( B & );//函数的原型说明
    };
class  B{	......
    friend  void  A::fun( B & );//定义友元函数
}；
    void  A::fun ( B  &b)	   //函数的完整定义
{
     ......		//函数体的定义
｝
```

### 友元类

![mark](http://media.sumblog.cn/blog/20190106/uJcOw1Hzet5B.png?imageslim)

友元关系是不能传递的。B类是A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。



## 重载流插入运算符和流提取运算符

`friend  istream &  operater >>(istream &, ClassName &);`



## 转换构造函数

完成从基本类型到类类型的转换

从类类型到基本类型的转换：

```
operator〈返回基本类型名〉（）
{
    ……
    return 〈基本类型值〉
}
```

